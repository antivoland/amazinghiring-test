# Транслитерация слов

> Нужно сделать транлитератор имен и фамилий с русского на английский и обратно. Например, Петров должен траслитерироваться в Petrov, Petroff,... Или наоборот, с английского Jurij переводится в Юрий. Файлы с таблицей траслитерации и с частотами имен/фамилий приложены к письму.
> 
> Хотелось бы, чтоб программа не выдавала заранее несуществующих имен и фамилий. Например, для имени Инесса не было бы варианта Inesssa. И работала на не знакомых словах которых нет в файле со статистикой.


## Решение

Для начала выделим отдельные N-граммы из слов частотного словаря. При этом количество слогов будет переменным: N слогов будет браться из середины слова и N-1, N-2,..1 с краёв. Все возможные слоги содержатся в словаре транлитерации [translit.txt](src/test/resources/translit.txt).

Рассмотрим случай с N = 3. Разбиение на слоги будем осуществлять всеми возможными способами. Например, имя `алекс` может быть представлено как `а` + `л` + `е` + `к` + `с`, равно как и `а` + `л` + `е` + `кс`. При этом в первом случае выбираются N-граммы `а`, `а+л`, `а+л+е`, `л+е+к`, `е+к+с`, `к+с` и `с`, во втором же случае образуется набор `а`, `а+л`, `а+л+е`, `л+е+кс`, `е+кс` и `кс`. Частотой появления N-граммы для данного слова положим отношение частоты самого слова, возведённую в некоторую степень FP, чтобы усилить правдоподобие наиболее частых слов, к количеству вариантов разбиения на слоги. Для выбранного выше имени частота составляет 21465, вариантов два, и результатом будет частотный словарик:

```
а, MIDDLE -> 2*21465^FP/2
а+л, MIDDLE -> 2*21465^FP/2
а+л+е, MIDDLE -> 2*21465^FP/2
л+е+к, MIDDLE -> 21465^FP/2
е+к+с, MIDDLE -> 21465^FP/2
к+с, RIGHT -> 21465^FP/2
с, RIGHT -> 21465^FP/2
л+е+кс, MIDDLE -> 21465^FP/2
е+кс, RIGHT -> 21465^FP/2
кс, RIGHT -> 21465^FP/2
```

Здесь `MIDDLE` и `RIGHT` означают позицию N-граммы в слове.

Применим это разбиение и заданный расчёт частоты для остальных слов для каждого из алфавитов и просуммируем частоты соответствующих N-грамм. Полученные частотные словари N-грамм применим далее для расчёта вероятности существования слова для заданного алфавита.

Показатель правдоподобия слова длины m определим как P(S<sub>1</sub>..S<sub>m</sub>) = P(S<sub>1</sub>) * P(S<sub>2</sub>|S<sub>1</sub>) * P(S<sub>3</sub>|S<sub>2</sub>, S<sub>1</sub>) * ... * P(S<sub>m</sub>|S<sub>m-1</sub>, S<sub>m-2</sub>), где P(S<sub>1</sub>) — доля присутствия слога S<sub>1</sub> в частотном словаре, P(S<sub>2</sub>|S<sub>1</sub>) — доля присутствия биграммы S<sub>1</sub>S<sub>2</sub> и т.д. Под долей присутствия я подразумеваю отношение частоты появления N-граммы к сумме всех частот.

Осталось непосредственно произвести транслитерацию. Для этого для каждого из возможных разбиений входного слова W<sub>1</sub>..W<sub>k</sub> подберём все возможные варианты транслитераций T<sub>1</sub>..T<sub>k</sub> и выберем пару, для которой совместная вероятность существования в соответствующих словарях максимальна, то есть выясним argmax<sub>W,T</sub> P(W) * W<sub>i</sub> * P(T) * W<sub>o</sub>. Дополнительные параметры W<sub>i</sub> и W<sub>o</sub> — выбранные некоторым образом веса, которые позволяют настраивать модель более тонко.

Пример использования можно найти в классе [TransliteratorTest](src/test/java/antivoland/amahir/translit/ngram/TransliteratorTest.java). Частотный словарь я сократил до 300000 первых строк, поскольку больше в память не помещалось:
 
```
¯\_(ツ)_/¯
```

Текущий вывод выглядит следующим образом:

```
Transliterating known latin names
alexandr -> александр (александр, 0)
sergey -> сергей (сергей, 0)
elena -> елена (елена, 0)
andrey -> андрей (андрей, 0)
alexey -> алексей (алексей, 0)
olga -> ольга (ольга, 0)
dmitrij -> дмитрий (дмитрий, 0)
tatyana -> татьяна (татьяна, 0)
irina -> ирина (ирина, 0)
inessa -> инеся (инесса, 2)
petrov -> петров (петров, 0)
petroff -> петров (петров, 0)
jurij -> юрий (юрий, 0)

Transliterating unknown latin names
avundiy -> авундий (авундий, 0)
plakilla -> плакилла (плакилла, 0)
usfazan -> юсфазан (усфазан, 1)
feognia -> феожня (феогния, 2)
epiktet -> епиктет (эпиктет, 1)

Transliterating known russian names
александр -> alexandr (alexandr, 0)
сергей -> sergey (sergey, 0)
елена -> elena (elena, 0)
андрей -> andrey (andrey, 0)
алексей -> alexey (alexey, 0)
ольга -> oljga (olga, 1)
дмитрий -> dmitry (dmitrij, 2)
татьяна -> tatjana (tatyana, 1)
ирина -> irina (irina, 0)
инесса -> inessa (inessa, 0)
петров -> petrov (petrov, 0)
петров -> petrov (petroff, 2)
юрий -> yury (jurij, 3)

Transliterating unknown russian names
авундий -> avyndy (avundiy, 2)
плакилла -> placilla (plakilla, 1)
усфазан -> usfasan (usfazan, 1)
феогния -> feognia (feognia, 0)
эпиктет -> epiktet (epiktet, 0)
```

Тут представлены входные и транслитерированные слова, в скобках же указаны ожидаемые транслитерирации и расстояния Левенштейна между ними и фактическими значениями.

Как видно, модель также умеет искать некоторые скрытые символы.

Можно разработать инструмент для определения оптимального количества слогов в N-грамме, однако триграммы подходят, казалось бы, оптимально. Следует также автоматически подбирать степень, в которую возводится частота и веса, с которыми перемножаются показатели правдоподобия слов.
